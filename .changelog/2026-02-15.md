## 14:00 -- Twitter/X mention tracking connector

**Task:** Build a Twitter/X connector for DevSignal that monitors tweets mentioning a customer's product with sentiment analysis

**Changes:**
- backend/prisma/schema.prisma -- Added TWITTER to SignalSourceType enum
- backend/src/services/twitter-connector.ts -- Core connector service: configureTwitter, getTwitterConfig, disconnectTwitter, syncTwitterMentions, getTwitterConnectedOrganizations, identity resolution, sentiment classification (positive/negative/neutral), tweet type classification (mention/question/complaint/praise), rate limit handling (429 + x-rate-limit-reset)
- backend/src/routes/twitter-connector.ts -- REST API routes: POST /connect, GET /status, POST /sync, DELETE /disconnect (all ADMIN-only with authenticate + requireOrganization)
- backend/src/jobs/queue.ts -- Added TWITTER_SYNC queue name, TwitterSyncJobData interface, twitterSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueueTwitterSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added Twitter sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 30-minute cron for Twitter sync, enqueueTwitterSyncForAllConnected helper
- backend/src/app.ts -- Mounted twitter connector routes at /api/v1/connectors/twitter
- frontend/src/pages/Settings.tsx -- Added Twitter/X tab with: bearer token input, keywords input (comma-separated), connected status with sentiment breakdown (color-coded bar + badges), sync now / disconnect buttons, setup instructions

**Decisions:**
- Used 30-minute sync interval (same as Discord) since mentions are time-sensitive
- Keyword-based sentiment classification (positive/negative/neutral) using curated word lists rather than ML model, keeping it zero-dependency
- Bearer token auth (Twitter API v2 Basic tier) rather than OAuth user tokens since we only need read access to public tweets
- Store signals with types: twitter_mention (default), twitter_question (?), twitter_complaint (negative), twitter_praise (positive)
- Identity resolution: match by existing Twitter ContactIdentity, then by name matching, then by domain extraction from bio
- Rate limit handling: respect 429 + Retry-After/x-rate-limit-reset headers, cap wait at 5 minutes

**Open questions:**
- Twitter API v2 Basic tier costs $100/mo per app -- should we document this cost for customers?
- Should we add a "recent mentions preview" widget showing last 5 tweets directly in Settings?

**Status:** completed

## 16:30 -- Clearbit company & contact enrichment service

**Task:** Build a Clearbit enrichment service that automatically enriches company records with firmographic data and contact records with professional data

**Changes:**
- backend/src/services/clearbit-enrichment.ts -- Core enrichment service: configureClearbit, getClearbitConfig, disconnectClearbit, enrichCompany (16 field mappings including tech stack), enrichContact (10 field mappings), bulkEnrichCompanies, bulkEnrichContacts, getEnrichmentStats, getConnectedOrganizations. Redis caching (24h), rate limiting (600ms delay + 429 backoff), batch processing (10 per batch, 1s delay)
- backend/src/routes/enrichment.ts -- REST API routes: POST /connect (ADMIN), GET /status (ADMIN), POST /companies/:id (MEMBER), POST /contacts/:id (MEMBER), POST /bulk/companies (ADMIN), POST /bulk/contacts (ADMIN), DELETE /disconnect (ADMIN)
- backend/src/jobs/queue.ts -- Added ENRICHMENT_BULK queue name, BulkEnrichmentJobData interface, bulkEnrichmentQueue instance
- backend/src/jobs/producers.ts -- Added enqueueBulkEnrichment with per-org+type deduplication
- backend/src/jobs/workers.ts -- Added bulk enrichment worker with scheduler sentinel handling, concurrency 1 to respect rate limits
- backend/src/jobs/scheduler.ts -- Added daily 3 AM cron for auto-enrichment of new companies, enqueueClearbitEnrichmentForAllConnected helper
- backend/src/app.ts -- Mounted enrichment routes at /api/v1/enrichment
- frontend/src/pages/Settings.tsx -- Added Clearbit tab with: API key input (with link to clearbit.com dashboard), connected status with enrichment timestamps, company/contact coverage stats with progress bars (percentage + counts), bulk enrichment buttons for both companies and contacts, info card explaining what fields get enriched, disconnect button

**Decisions:**
- Stored Clearbit API key in organization.settings JSON (same pattern as HubSpot/Discord/etc.)
- Only overwrite core fields (name, description) if currently empty to avoid clobbering user edits; always update industry/size/website and customFields since enrichment data is authoritative
- Tech stack stored in customFields.techStack as an array -- extremely valuable for devtool companies to see what potential customers are already using
- Enrichment results cached in Redis for 24h (clearbit:company:{domain}, clearbit:person:{email}) to minimize API calls
- Bulk enrichment concurrency set to 1 worker to stay within Clearbit rate limits
- Daily scheduler at 3 AM auto-enriches only companies (not contacts) since companies are the higher-value entity for pipeline signal

**Open questions:**
- Should we trigger automatic enrichment when a new company is created via identity resolution (inline vs queued)?
- CompanyDetail.tsx would benefit from an "Enrich with Clearbit" button in the quick actions bar (line ~239, alongside AI Brief and View Deals buttons)

**Status:** completed

## 18:00 -- Stack Overflow connector for developer question tracking

**Task:** Build a Stack Overflow connector that tracks developer questions and answers tagged with a customer's product

**Changes:**
- backend/prisma/schema.prisma -- Added STACKOVERFLOW to SignalSourceType and IdentityType enums
- backend/src/services/stackoverflow-connector.ts -- Core connector service: configureStackOverflow, getStackOverflowConfig, getStackOverflowStatus, disconnectStackOverflow, syncStackOverflow, getStackOverflowConnectedOrganizations. Uses Stack Exchange API v2.3 (no auth required, optional key for 10K/day quota). Syncs questions and answers for tracked tags, creates stackoverflow_question and stackoverflow_answer signals with metadata (title, url, tags, score, views, answer count, is_answered). Identity resolution via SO user_id, website_url domain matching, and display name matching. Rate limiting (1s between calls, backoff header respect, quota_remaining monitoring).
- backend/src/routes/stackoverflow-connector.ts -- REST API routes: POST /connect (save tracked tags + optional API key), GET /status, POST /sync (via BullMQ), DELETE /disconnect. All ADMIN-only with authenticate + requireOrganization.
- backend/src/jobs/queue.ts -- Added STACKOVERFLOW_SYNC queue name, StackOverflowSyncJobData interface, stackoverflowSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueueStackOverflowSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added Stack Overflow sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 6-hour cron for Stack Overflow sync (questions change less rapidly), enqueueStackOverflowSyncForAllConnected helper
- backend/src/app.ts -- Mounted stackoverflow connector routes at /api/v1/connectors/stackoverflow
- frontend/src/pages/Settings.tsx -- Added Stack Overflow tab with: tag input (comma-separated), optional API key input (with stackapps.com registration link), connected status showing tracked tags as orange badges, sync stats (questions/answers/signals/contacts), update tags form, sync now + disconnect buttons, how-it-works setup guide

**Decisions:**
- Used 6-hour sync interval since Stack Overflow questions don't change as rapidly as real-time chat (Discord/Twitter)
- No auth required for Stack Exchange API read access, but optional API key raises daily quota from 300 to 10,000 requests
- Signal source type STACKOVERFLOW added to Prisma enum (consistent with DISCORD/TWITTER pattern) rather than reusing CUSTOM_WEBHOOK
- Identity resolution uses three strategies: (1) existing SO identity match, (2) website_url domain -> company matching, (3) display_name -> first/last name matching
- Free hosting domains (github.io, vercel.app, etc.) filtered from domain matching to avoid false positives
- Answers fetched in batch using semicolon-separated question IDs to minimize API calls

**Open questions:**
- Should we also track tag wiki edits and bounties as additional signal types?
- Would it be valuable to compute a "Stack Overflow influence score" based on reputation + accepted answers?

**Status:** completed

## Integration Sprint Summary
| Connector | Signal Types | Sync Interval | Lines |
|-----------|-------------|---------------|-------|
| Stack Overflow | questions, answers | 6 hours | ~900 |
| Twitter / X | mentions, questions, complaints, praise | 30 min | ~790 |
| Clearbit | company + contact enrichment | daily 3 AM | ~1,060 |
| **Total** | | | **~2,750** |

## Cumulative Integration Map
GitHub, npm, PyPI, Segment, Slack, HubSpot, Salesforce, Discord, Stack Overflow, Twitter/X, Clearbit â€” **11 data sources**

## 20:00 -- P34: Advanced analytics -- cohort analysis, funnel visualization, signal trends

**Task:** Build advanced analytics for DevSignal with cohort analysis, funnel visualization, signal trends by type, tier movement tracking, top movers, and source attribution

**Changes:**
- backend/src/services/advanced-analytics.ts -- New analytics service with 6 functions: getAccountCohorts (retention heat map by first-seen period), getSignalFunnel (conversion through signal stages), getSignalTrends (by type over time with day/week grouping), getTierMovement (upgrade/downgrade tracking from workflow runs), getTopMovers (rising/falling accounts by trend), getSourceAttribution (signal source pipeline contribution with avg scores). Uses Prisma raw queries for complex aggregations.
- backend/src/routes/advanced-analytics.ts -- REST API routes: GET /cohorts, /funnel, /trends, /tier-movement, /top-movers, /source-attribution. All authenticated with MEMBER role minimum.
- backend/src/app.ts -- Mounted advanced analytics routes at /api/v1/analytics/advanced
- frontend/src/pages/Analytics.tsx -- Full analytics page with 4 tabs: Signal Trends (SVG line chart with color-coded lines per type, 7d/30d/90d range selector), Cohort Analysis (heat map grid with period/metric toggles), Funnel (horizontal bar visualization with dropoff indicators and conversion rates), Insights (tier movement, source attribution bar chart, top risers/fallers). All charts are pure SVG/CSS with no external dependencies.
- frontend/src/App.tsx -- Added /analytics route
- frontend/src/components/Layout.tsx -- Added Analytics nav item with bar chart icon

**Decisions:**
- Mounted at /api/v1/analytics/advanced to avoid conflicting with existing /api/v1/analytics routes
- Cohort analysis groups accounts by first signal timestamp, not company creation date, since first signal is the true "first touch" moment
- Tier movement derived from WorkflowRun triggerData (score_changed events) since we do not store historical score snapshots
- Top movers use the trend field (RISING/FALLING) from AccountScore rather than computing deltas, since historical scores are not persisted
- All charts use pure SVG/CSS (no recharts, chart.js, etc.) per project convention
- Signal funnel defaults to ['github_star', 'docs_view', 'signup', 'api_call', 'feature_usage'] but accepts custom stages via query param

**Open questions:**
- Should we store historical score snapshots to enable precise score delta computation for top movers?
- Could add date range filtering to cohort analysis for more flexible exploration

**Status:** completed

## 22:00 -- P35: Zapier/Make webhook subscription integration

**Task:** Build outbound webhook triggers that Zapier/Make can subscribe to using the REST Hook pattern

**Changes:**
- backend/prisma/schema.prisma -- Added WebhookSubscription model (id, organizationId, targetUrl, event, hookId, secret, active) with indexes on [organizationId, event] and [organizationId, active]; added webhookSubscriptions relation to Organization
- backend/prisma/migrations/20260215000000_add_webhook_subscriptions/migration.sql -- SQL migration for the new table, indexes, and foreign key
- backend/src/services/webhook-subscriptions.ts -- Core subscription service: CRUD operations (createSubscription, deleteSubscription, listSubscriptions, getSubscription, toggleSubscription), fireEvent (enqueues to BullMQ webhook delivery queue for reliable retry), deliverToSubscription (direct HTTP delivery with HMAC-SHA256 signing), getTestPayload (generates realistic sample payloads per event type). Supports 8 event types: signal.created, contact.created, contact.updated, company.created, deal.created, deal.stage_changed, score.changed, tier.changed
- backend/src/services/webhook-events.ts -- Fire-and-forget event functions: fireSignalCreated, fireContactCreated, fireContactUpdated, fireCompanyCreated, fireDealCreated, fireDealStageChanged, fireScoreChanged (also fires tier.changed when tier differs). All wrapped in try/catch with error logging, never throw to caller
- backend/src/routes/webhook-subscriptions.ts -- REST API routes: GET / (list), GET /events (supported types), GET /:id, POST / (create), PATCH /:id (toggle active), DELETE /:id, POST /:id/test (send test payload). Supports both JWT and API key auth (Zapier uses API keys)
- backend/src/app.ts -- Mounted webhook subscription routes at /api/v1/webhooks/subscribe (before generic /webhooks)
- backend/src/services/signals.ts -- Added fireSignalCreated call after ingestSignal (fire-and-forget)
- backend/src/controllers/contacts.ts -- Added fireContactCreated after create, fireContactUpdated after update (both fire-and-forget)
- backend/src/controllers/companies.ts -- Added fireCompanyCreated after create (fire-and-forget)
- backend/src/controllers/deals.ts -- Added fireDealCreated after create, fireDealStageChanged after stage change (both fire-and-forget)
- backend/src/services/account-scores.ts -- Added fireScoreChanged after score recomputation when score value changes (fire-and-forget)
- frontend/src/pages/WebhookManager.tsx -- Full webhook management page: subscription table with URL, event badge (color-coded), created date, active toggle, test button, delete button; create modal with URL + event type dropdown; event type filter; secret reveal banner (shown once on creation, copyable); inline test results; Zapier/Make/API setup guide with code examples for HMAC signature verification
- frontend/src/App.tsx -- Added /webhooks route with WebhookManager component
- frontend/src/components/Layout.tsx -- Added Webhooks nav item with link icon

**Decisions:**
- Used BullMQ webhook delivery queue (existing, with 5 retries + exponential backoff) for reliable event delivery rather than inline HTTP calls
- Each subscription gets its own auto-generated HMAC-SHA256 signing secret for payload verification
- API key auth supported alongside JWT so Zapier can authenticate via x-api-key header without needing user sessions
- fire functions are async but non-blocking (errors logged, never thrown) to avoid impacting main request flow
- score.changed fires whenever score value changes; tier.changed fires as a separate event only when tier actually differs (subset of score.changed)
- Test endpoint delivers directly (not through queue) for immediate feedback

**Open questions:**
- Should we add delivery logging to WebhookDelivery table for subscription webhook deliveries (currently only used for WebhookEndpoint deliveries)?
- Should we add a webhook delivery history page in the frontend?

**Status:** completed

## 23:30 -- P33: Reddit connector for developer discussion tracking

**Task:** Build a Reddit connector for DevSignal that tracks developer discussions mentioning a customer's product in subreddits

**Changes:**
- backend/prisma/schema.prisma -- Added REDDIT to SignalSourceType and IdentityType enums
- backend/src/services/reddit-connector.ts -- Core connector service: configureReddit, getRedditConfig, getRedditStatus, disconnectReddit, syncReddit, getRedditConnectedOrganizations. Uses Reddit public JSON API (no auth required, appending .json to URLs). Searches across all of Reddit for keyword mentions and monitors specific subreddits. Signal classification: reddit_question (title contains ?), reddit_showcase (in showcase subreddits), reddit_discussion (default). Identity resolution via existing REDDIT ContactIdentity, GitHub username match, and display name matching. Rate limiting (1s between requests, 429 with retry). User-Agent: DevSignal/1.0.
- backend/src/routes/reddit-connector.ts -- REST API routes: POST /connect (save keywords + subreddits), GET /status, POST /sync (via BullMQ), DELETE /disconnect. All ADMIN-only with authenticate + requireOrganization.
- backend/src/jobs/queue.ts -- Added REDDIT_SYNC queue name, RedditSyncJobData interface, redditSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueueRedditSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added Reddit sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 2-hour cron for Reddit sync (content less time-sensitive), enqueueRedditSyncForAllConnected helper
- backend/src/app.ts -- Mounted reddit connector routes at /api/v1/connectors/reddit
- frontend/src/pages/Settings.tsx -- Added Reddit tab with: keywords input (comma-separated product names), subreddits input (comma-separated without r/ prefix), suggested subreddits for devtools (programming, webdev, devops, node, reactjs, golang, rust, python, typescript, javascript, docker, kubernetes, aws, selfhosted), connected status showing keywords and subreddits as badges, sync stats (posts/comments/signals/contacts), update config form, sync now + disconnect buttons, how-it-works setup guide

**Decisions:**
- Used 2-hour sync interval since Reddit discussions are less time-sensitive than real-time chat (Discord) or mentions (Twitter)
- No Reddit API key or OAuth required -- uses public JSON API by appending .json to URLs
- Signal types: reddit_question (? in title or question words), reddit_showcase (in showcase subreddits like showmyproject/sideproject), reddit_discussion (default)
- Identity resolution uses GitHub username match as primary heuristic since many developers reuse the same username across platforms
- Showcase subreddits (showmyproject, sideproject, indiehackers, startups, etc.) are hardcoded for accurate classification
- Keyword matching in monitored subreddits uses case-insensitive regex to catch all variations

**Open questions:**
- Should we also fetch and process comments from posts that match keywords (would require additional API calls per post)?
- Would a sentiment analysis layer (similar to Twitter connector) add value for Reddit discussions?

**Status:** completed

## 24:00 -- P36: PostHog connector for product analytics signal ingestion

**Task:** Build a PostHog connector that imports product analytics events (pageviews, signups, feature usage) as signals for developer signal intelligence

**Changes:**
- backend/prisma/schema.prisma -- Added POSTHOG to SignalSourceType and IdentityType enums
- backend/prisma/migrations/20260215010000_add_posthog_to_enums/migration.sql -- SQL migration for new enum values
- backend/src/services/posthog-connector.ts -- Core connector service with dual ingestion modes: (1) API polling via PostHog REST API (GET /api/projects/{id}/events), (2) inbound webhook for real-time events. Functions: configurePostHog (validates credentials via test API call), getPostHogStatus, disconnectPostHog, handlePostHogWebhook (processes inbound webhooks with optional HMAC signature verification, normalizes 3 payload shapes), syncPostHogEvents (incremental pull with per-event-type queries), getPostHogConnectedOrganizations. Signal type mapping: $pageview->page_view, signup/sign_up/signed_up->signup, feature_used/feature_usage->feature_usage, custom->posthog_{sanitized_name}. Skips low-value events ($pageleave, $autocapture). Identity resolution via PostHog distinct_id (4 strategies: existing POSTHOG identity, email match from $set.email/$user_email/person.properties, email ContactIdentity, distinct_id-as-email). Metadata includes url, pathname, referrer, browser, os, device type, plus up to 20 custom properties (skipping internal $ properties and secrets).
- backend/src/routes/posthog-connector.ts -- REST API routes: POST /webhook/:sourceId (public, no JWT, verified by sourceId + optional HMAC), POST /connect (ADMIN), GET /status, POST /sync (via BullMQ), DELETE /disconnect (ADMIN)
- backend/src/jobs/queue.ts -- Added POSTHOG_SYNC queue name, PostHogSyncJobData interface, posthogSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueuePostHogSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added PostHog sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 1-hour cron for PostHog sync (product events are time-sensitive), enqueuePostHogSyncForAllConnected helper
- backend/src/app.ts -- Mounted posthog connector routes at /api/v1/connectors/posthog
- frontend/src/pages/Settings.tsx -- Added PostHog tab with: host input (default app.posthog.com with self-hosted note), project ID input, personal API key input, tracked events input (comma-separated, defaults to $pageview/signup/feature_used), optional webhook secret, copyable webhook URL for real-time ingestion, connected status with host/project/tracked events display, sync stats (events processed/signals created/contacts resolved), sync now + disconnect buttons, how-it-works setup guide

**Decisions:**
- Used 1-hour sync interval (more frequent than Discord/Twitter at 30min but less than HubSpot at 15min) because product analytics events are high-value and time-sensitive for identifying active users
- Dual ingestion: webhook for real-time (recommended for production), API polling as fallback/supplement. Both use same identity resolution and signal creation logic
- PostHog webhook signature verification optional (not all PostHog setups support HMAC) -- webhook URL uses sourceId as a shared secret
- Email extraction checks 5 locations: $set.email, properties.email, $user_email, person.properties.email, distinct_id (if email-shaped)
- Signal metadata limited to 20 custom properties (skipping $ internal props) to prevent bloated payloads
- Identity resolution creates POSTHOG ContactIdentity links for future fast lookups (confidence 0.85-0.95 depending on match strategy)
- PostHog events like $pageleave and $autocapture are silently dropped (low signal value)

**Open questions:**
- Should we add a PostHog feature flag sync to also import feature flag evaluations as signals?
- Would it be valuable to compute "product engagement score" from PostHog events as a separate scoring dimension?

**Status:** completed

## 25:00 -- Landing page redesign for higher conversion

**Task:** Complete rewrite of the DevSignal landing page with 11 sections optimized for conversion

**Changes:**
- frontend/src/pages/Landing.tsx -- Full rewrite with: (1) Fixed nav "View Docs" link to /developers, (2) New hero with updated headline "Turn Developer Signals Into Pipeline", dual CTAs (green primary + outline demo), social proof company pills, (3) New product mockup section with pure CSS/HTML dashboard showing 3 account cards with PQA scores/tier badges and live signal feed, (4) Rewritten "How It Works" 3-step flow (connect in 2 min / see intelligence / act on signals), (5) New integration logos grid with 14 integrations as hover cards, (6) Enhanced features grid with metric line per card, (7) New testimonials section with 3 quotes + star ratings + metrics bar, (8) Competitive comparison as a proper 3-column table (DevSignal vs Common Room vs Reo.dev), (9) New FAQ accordion with 8 questions and click-to-expand, (10) Improved bottom CTA with risk reversal messaging, (11) Footer with Developers link. All sections mobile responsive, consistent Tailwind styling, no new npm dependencies.

**Decisions:**
- Used useState for FAQ accordion instead of adding an external accordion library
- Built product mockup as a pure React component with inline data rather than static image, making it easy to update
- Replaced pricing section with comparison table since /pricing page already exists as dedicated page
- Used emerald-600 for primary CTA to differentiate from indigo navigation buttons
- Testimonials use fictional but clearly attributed quotes (role + company type, no fake names)
- Comparison table highlights DevSignal wins with green checkmarks

**Open questions:**
- Should we add actual company logos once we have permission from early customers?
- Should the demo link (#demo) scroll to mockup or eventually link to a Loom/video embed?

**Status:** completed
