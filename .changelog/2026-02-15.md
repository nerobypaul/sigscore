## 14:00 -- Twitter/X mention tracking connector

**Task:** Build a Twitter/X connector for DevSignal that monitors tweets mentioning a customer's product with sentiment analysis

**Changes:**
- backend/prisma/schema.prisma -- Added TWITTER to SignalSourceType enum
- backend/src/services/twitter-connector.ts -- Core connector service: configureTwitter, getTwitterConfig, disconnectTwitter, syncTwitterMentions, getTwitterConnectedOrganizations, identity resolution, sentiment classification (positive/negative/neutral), tweet type classification (mention/question/complaint/praise), rate limit handling (429 + x-rate-limit-reset)
- backend/src/routes/twitter-connector.ts -- REST API routes: POST /connect, GET /status, POST /sync, DELETE /disconnect (all ADMIN-only with authenticate + requireOrganization)
- backend/src/jobs/queue.ts -- Added TWITTER_SYNC queue name, TwitterSyncJobData interface, twitterSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueueTwitterSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added Twitter sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 30-minute cron for Twitter sync, enqueueTwitterSyncForAllConnected helper
- backend/src/app.ts -- Mounted twitter connector routes at /api/v1/connectors/twitter
- frontend/src/pages/Settings.tsx -- Added Twitter/X tab with: bearer token input, keywords input (comma-separated), connected status with sentiment breakdown (color-coded bar + badges), sync now / disconnect buttons, setup instructions

**Decisions:**
- Used 30-minute sync interval (same as Discord) since mentions are time-sensitive
- Keyword-based sentiment classification (positive/negative/neutral) using curated word lists rather than ML model, keeping it zero-dependency
- Bearer token auth (Twitter API v2 Basic tier) rather than OAuth user tokens since we only need read access to public tweets
- Store signals with types: twitter_mention (default), twitter_question (?), twitter_complaint (negative), twitter_praise (positive)
- Identity resolution: match by existing Twitter ContactIdentity, then by name matching, then by domain extraction from bio
- Rate limit handling: respect 429 + Retry-After/x-rate-limit-reset headers, cap wait at 5 minutes

**Open questions:**
- Twitter API v2 Basic tier costs $100/mo per app -- should we document this cost for customers?
- Should we add a "recent mentions preview" widget showing last 5 tweets directly in Settings?

**Status:** completed

## 16:30 -- Clearbit company & contact enrichment service

**Task:** Build a Clearbit enrichment service that automatically enriches company records with firmographic data and contact records with professional data

**Changes:**
- backend/src/services/clearbit-enrichment.ts -- Core enrichment service: configureClearbit, getClearbitConfig, disconnectClearbit, enrichCompany (16 field mappings including tech stack), enrichContact (10 field mappings), bulkEnrichCompanies, bulkEnrichContacts, getEnrichmentStats, getConnectedOrganizations. Redis caching (24h), rate limiting (600ms delay + 429 backoff), batch processing (10 per batch, 1s delay)
- backend/src/routes/enrichment.ts -- REST API routes: POST /connect (ADMIN), GET /status (ADMIN), POST /companies/:id (MEMBER), POST /contacts/:id (MEMBER), POST /bulk/companies (ADMIN), POST /bulk/contacts (ADMIN), DELETE /disconnect (ADMIN)
- backend/src/jobs/queue.ts -- Added ENRICHMENT_BULK queue name, BulkEnrichmentJobData interface, bulkEnrichmentQueue instance
- backend/src/jobs/producers.ts -- Added enqueueBulkEnrichment with per-org+type deduplication
- backend/src/jobs/workers.ts -- Added bulk enrichment worker with scheduler sentinel handling, concurrency 1 to respect rate limits
- backend/src/jobs/scheduler.ts -- Added daily 3 AM cron for auto-enrichment of new companies, enqueueClearbitEnrichmentForAllConnected helper
- backend/src/app.ts -- Mounted enrichment routes at /api/v1/enrichment
- frontend/src/pages/Settings.tsx -- Added Clearbit tab with: API key input (with link to clearbit.com dashboard), connected status with enrichment timestamps, company/contact coverage stats with progress bars (percentage + counts), bulk enrichment buttons for both companies and contacts, info card explaining what fields get enriched, disconnect button

**Decisions:**
- Stored Clearbit API key in organization.settings JSON (same pattern as HubSpot/Discord/etc.)
- Only overwrite core fields (name, description) if currently empty to avoid clobbering user edits; always update industry/size/website and customFields since enrichment data is authoritative
- Tech stack stored in customFields.techStack as an array -- extremely valuable for devtool companies to see what potential customers are already using
- Enrichment results cached in Redis for 24h (clearbit:company:{domain}, clearbit:person:{email}) to minimize API calls
- Bulk enrichment concurrency set to 1 worker to stay within Clearbit rate limits
- Daily scheduler at 3 AM auto-enriches only companies (not contacts) since companies are the higher-value entity for pipeline signal

**Open questions:**
- Should we trigger automatic enrichment when a new company is created via identity resolution (inline vs queued)?
- CompanyDetail.tsx would benefit from an "Enrich with Clearbit" button in the quick actions bar (line ~239, alongside AI Brief and View Deals buttons)

**Status:** completed

## 18:00 -- Stack Overflow connector for developer question tracking

**Task:** Build a Stack Overflow connector that tracks developer questions and answers tagged with a customer's product

**Changes:**
- backend/prisma/schema.prisma -- Added STACKOVERFLOW to SignalSourceType and IdentityType enums
- backend/src/services/stackoverflow-connector.ts -- Core connector service: configureStackOverflow, getStackOverflowConfig, getStackOverflowStatus, disconnectStackOverflow, syncStackOverflow, getStackOverflowConnectedOrganizations. Uses Stack Exchange API v2.3 (no auth required, optional key for 10K/day quota). Syncs questions and answers for tracked tags, creates stackoverflow_question and stackoverflow_answer signals with metadata (title, url, tags, score, views, answer count, is_answered). Identity resolution via SO user_id, website_url domain matching, and display name matching. Rate limiting (1s between calls, backoff header respect, quota_remaining monitoring).
- backend/src/routes/stackoverflow-connector.ts -- REST API routes: POST /connect (save tracked tags + optional API key), GET /status, POST /sync (via BullMQ), DELETE /disconnect. All ADMIN-only with authenticate + requireOrganization.
- backend/src/jobs/queue.ts -- Added STACKOVERFLOW_SYNC queue name, StackOverflowSyncJobData interface, stackoverflowSyncQueue instance
- backend/src/jobs/producers.ts -- Added enqueueStackOverflowSync with per-org deduplication
- backend/src/jobs/workers.ts -- Added Stack Overflow sync worker with scheduler sentinel handling
- backend/src/jobs/scheduler.ts -- Added 6-hour cron for Stack Overflow sync (questions change less rapidly), enqueueStackOverflowSyncForAllConnected helper
- backend/src/app.ts -- Mounted stackoverflow connector routes at /api/v1/connectors/stackoverflow
- frontend/src/pages/Settings.tsx -- Added Stack Overflow tab with: tag input (comma-separated), optional API key input (with stackapps.com registration link), connected status showing tracked tags as orange badges, sync stats (questions/answers/signals/contacts), update tags form, sync now + disconnect buttons, how-it-works setup guide

**Decisions:**
- Used 6-hour sync interval since Stack Overflow questions don't change as rapidly as real-time chat (Discord/Twitter)
- No auth required for Stack Exchange API read access, but optional API key raises daily quota from 300 to 10,000 requests
- Signal source type STACKOVERFLOW added to Prisma enum (consistent with DISCORD/TWITTER pattern) rather than reusing CUSTOM_WEBHOOK
- Identity resolution uses three strategies: (1) existing SO identity match, (2) website_url domain -> company matching, (3) display_name -> first/last name matching
- Free hosting domains (github.io, vercel.app, etc.) filtered from domain matching to avoid false positives
- Answers fetched in batch using semicolon-separated question IDs to minimize API calls

**Open questions:**
- Should we also track tag wiki edits and bounties as additional signal types?
- Would it be valuable to compute a "Stack Overflow influence score" based on reputation + accepted answers?

**Status:** completed

## Integration Sprint Summary
| Connector | Signal Types | Sync Interval | Lines |
|-----------|-------------|---------------|-------|
| Stack Overflow | questions, answers | 6 hours | ~900 |
| Twitter / X | mentions, questions, complaints, praise | 30 min | ~790 |
| Clearbit | company + contact enrichment | daily 3 AM | ~1,060 |
| **Total** | | | **~2,750** |

## Cumulative Integration Map
GitHub, npm, PyPI, Segment, Slack, HubSpot, Salesforce, Discord, Stack Overflow, Twitter/X, Clearbit â€” **11 data sources**

## 20:00 -- P34: Advanced analytics -- cohort analysis, funnel visualization, signal trends

**Task:** Build advanced analytics for DevSignal with cohort analysis, funnel visualization, signal trends by type, tier movement tracking, top movers, and source attribution

**Changes:**
- backend/src/services/advanced-analytics.ts -- New analytics service with 6 functions: getAccountCohorts (retention heat map by first-seen period), getSignalFunnel (conversion through signal stages), getSignalTrends (by type over time with day/week grouping), getTierMovement (upgrade/downgrade tracking from workflow runs), getTopMovers (rising/falling accounts by trend), getSourceAttribution (signal source pipeline contribution with avg scores). Uses Prisma raw queries for complex aggregations.
- backend/src/routes/advanced-analytics.ts -- REST API routes: GET /cohorts, /funnel, /trends, /tier-movement, /top-movers, /source-attribution. All authenticated with MEMBER role minimum.
- backend/src/app.ts -- Mounted advanced analytics routes at /api/v1/analytics/advanced
- frontend/src/pages/Analytics.tsx -- Full analytics page with 4 tabs: Signal Trends (SVG line chart with color-coded lines per type, 7d/30d/90d range selector), Cohort Analysis (heat map grid with period/metric toggles), Funnel (horizontal bar visualization with dropoff indicators and conversion rates), Insights (tier movement, source attribution bar chart, top risers/fallers). All charts are pure SVG/CSS with no external dependencies.
- frontend/src/App.tsx -- Added /analytics route
- frontend/src/components/Layout.tsx -- Added Analytics nav item with bar chart icon

**Decisions:**
- Mounted at /api/v1/analytics/advanced to avoid conflicting with existing /api/v1/analytics routes
- Cohort analysis groups accounts by first signal timestamp, not company creation date, since first signal is the true "first touch" moment
- Tier movement derived from WorkflowRun triggerData (score_changed events) since we do not store historical score snapshots
- Top movers use the trend field (RISING/FALLING) from AccountScore rather than computing deltas, since historical scores are not persisted
- All charts use pure SVG/CSS (no recharts, chart.js, etc.) per project convention
- Signal funnel defaults to ['github_star', 'docs_view', 'signup', 'api_call', 'feature_usage'] but accepts custom stages via query param

**Open questions:**
- Should we store historical score snapshots to enable precise score delta computation for top movers?
- Could add date range filtering to cohort analysis for more flexible exploration

**Status:** completed

## 22:00 -- P35: Zapier/Make webhook subscription integration

**Task:** Build outbound webhook triggers that Zapier/Make can subscribe to using the REST Hook pattern

**Changes:**
- backend/prisma/schema.prisma -- Added WebhookSubscription model (id, organizationId, targetUrl, event, hookId, secret, active) with indexes on [organizationId, event] and [organizationId, active]; added webhookSubscriptions relation to Organization
- backend/prisma/migrations/20260215000000_add_webhook_subscriptions/migration.sql -- SQL migration for the new table, indexes, and foreign key
- backend/src/services/webhook-subscriptions.ts -- Core subscription service: CRUD operations (createSubscription, deleteSubscription, listSubscriptions, getSubscription, toggleSubscription), fireEvent (enqueues to BullMQ webhook delivery queue for reliable retry), deliverToSubscription (direct HTTP delivery with HMAC-SHA256 signing), getTestPayload (generates realistic sample payloads per event type). Supports 8 event types: signal.created, contact.created, contact.updated, company.created, deal.created, deal.stage_changed, score.changed, tier.changed
- backend/src/services/webhook-events.ts -- Fire-and-forget event functions: fireSignalCreated, fireContactCreated, fireContactUpdated, fireCompanyCreated, fireDealCreated, fireDealStageChanged, fireScoreChanged (also fires tier.changed when tier differs). All wrapped in try/catch with error logging, never throw to caller
- backend/src/routes/webhook-subscriptions.ts -- REST API routes: GET / (list), GET /events (supported types), GET /:id, POST / (create), PATCH /:id (toggle active), DELETE /:id, POST /:id/test (send test payload). Supports both JWT and API key auth (Zapier uses API keys)
- backend/src/app.ts -- Mounted webhook subscription routes at /api/v1/webhooks/subscribe (before generic /webhooks)
- backend/src/services/signals.ts -- Added fireSignalCreated call after ingestSignal (fire-and-forget)
- backend/src/controllers/contacts.ts -- Added fireContactCreated after create, fireContactUpdated after update (both fire-and-forget)
- backend/src/controllers/companies.ts -- Added fireCompanyCreated after create (fire-and-forget)
- backend/src/controllers/deals.ts -- Added fireDealCreated after create, fireDealStageChanged after stage change (both fire-and-forget)
- backend/src/services/account-scores.ts -- Added fireScoreChanged after score recomputation when score value changes (fire-and-forget)
- frontend/src/pages/WebhookManager.tsx -- Full webhook management page: subscription table with URL, event badge (color-coded), created date, active toggle, test button, delete button; create modal with URL + event type dropdown; event type filter; secret reveal banner (shown once on creation, copyable); inline test results; Zapier/Make/API setup guide with code examples for HMAC signature verification
- frontend/src/App.tsx -- Added /webhooks route with WebhookManager component
- frontend/src/components/Layout.tsx -- Added Webhooks nav item with link icon

**Decisions:**
- Used BullMQ webhook delivery queue (existing, with 5 retries + exponential backoff) for reliable event delivery rather than inline HTTP calls
- Each subscription gets its own auto-generated HMAC-SHA256 signing secret for payload verification
- API key auth supported alongside JWT so Zapier can authenticate via x-api-key header without needing user sessions
- fire functions are async but non-blocking (errors logged, never thrown) to avoid impacting main request flow
- score.changed fires whenever score value changes; tier.changed fires as a separate event only when tier actually differs (subset of score.changed)
- Test endpoint delivers directly (not through queue) for immediate feedback

**Open questions:**
- Should we add delivery logging to WebhookDelivery table for subscription webhook deliveries (currently only used for WebhookEndpoint deliveries)?
- Should we add a webhook delivery history page in the frontend?

**Status:** completed
