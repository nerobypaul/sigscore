## 01:00 — Intercom connector, rate limiting, SEO meta tags

**Task:** Complete Cycle 4: Intercom support ticket connector, security hardening via rate limiting, and SEO meta tags

**Changes:**
- backend/src/services/intercom-connector.ts — Full Intercom connector: webhook-driven signal ingestion (conversation open/reply/close/rated), API polling sync for conversations, HMAC-SHA1 signature verification, identity resolution (email → name → Intercom user ID)
- backend/src/routes/intercom-connector.ts — REST routes: POST /webhook/:sourceId (public, HMAC-verified), POST /connect, GET /status, POST /sync, DELETE /disconnect
- backend/src/jobs/queue.ts — Added INTERCOM_SYNC queue and IntercomSyncJobData interface
- backend/src/jobs/producers.ts — Added enqueueIntercomSync producer function
- backend/src/middleware/rate-limit.ts — Extracted 5 rate limiters: auth (5/min), api (100/min), webhook (200/min), demo (3/min), signal (500/min)
- backend/src/app.ts — Replaced inline rate limiters with middleware imports, registered Intercom connector routes
- backend/prisma/schema.prisma — Added INTERCOM to SignalSourceType and IdentityType enums
- backend/prisma/migrations/20260216010000_add_intercom_signal_source_type/ — Migration for INTERCOM enum values
- frontend/index.html — Added SEO meta tags: Open Graph, Twitter Cards, description, canonical URL, theme-color, favicon links

**Decisions:**
- Intercom webhook verification uses HMAC-SHA1 (matching Intercom's X-Hub-Signature header format)
- Rate limiters use in-memory store; documented Redis store swap for multi-instance deployments
- Forgot-password endpoint added to auth limiter scope

**Status:** completed

## 14:30 — Frontend settings UI for Intercom and Zendesk connectors

**Task:** Build frontend settings UI tabs for Intercom and Zendesk connectors in the Settings page

**Changes:**
- frontend/src/pages/Settings.tsx — Added IntercomStatus and ZendeskStatus interfaces, added 'intercom' and 'zendesk' to TabId union type, added tabs to TABS array, added tab rendering blocks with lazy mount, added IntercomIcon and ZendeskIcon inline SVG components, added INTERCOM_EVENTS and ZENDESK_EVENTS constant arrays, added full IntercomTab component (connect form with access token, webhook secret, event checkboxes; connected state with webhook URL copy, signal stats grid, sync results, sync/disconnect actions), added full ZendeskTab component (connect form with subdomain+suffix input, email, API token, webhook secret, event checkboxes; connected state with subdomain display, webhook URL copy, signal stats grid, sync results, sync/disconnect actions)

**Decisions:**
- Kept both components inline in Settings.tsx to match the existing monolithic pattern (all other connector tabs are in the same file)
- Intercom uses blue accent color (#286EFA) matching brand; Zendesk uses emerald (#03363D) matching brand
- Intercom access token is optional (supports webhook-only mode); Zendesk requires subdomain+email+API token (mandatory for API auth)
- All event types checked by default for both connectors
- Followed exact same state management, polling, error handling, and UI card patterns as PostHog/Reddit/StackOverflow tabs

**Status:** completed

## 18:45 — Load testing setup for Show HN traffic simulation

**Task:** Create a pure Node.js load test suite to validate DevSignal can handle 2,000-5,000 visitors in 4 hours (Show HN traffic pattern)
**Changes:**
- tests/load/run.js — Main load test runner: CLI args (--quick, --duration N), pre-flight connectivity check, automatic auth via demo/seed, phased traffic simulation with ramping concurrency, JSON report export
- tests/load/config.js — Endpoint definitions with weighted traffic distribution (9 endpoints, 40% landing page / 10% health / 10% API docs / 10% demo status / 5% demo seed / 10% companies / 5% signals / 5% auth login / 5% contacts), 4-phase traffic profile (ramp-up 15min / peak 90min / sustained 60min / tail 75min), and quick-test profile for CI
- tests/load/http-client.js — Minimal HTTP client built on node:http/https with keep-alive connection pooling (256 sockets), timeout handling, and latency measurement via hrtime
- tests/load/stats.js — Statistics collector with per-endpoint latency percentiles (P50/P95/P99/min/max/mean), status code distribution, RPS tracking (sustained/peak), max concurrent connections, formatted terminal report
- tests/load/README.md — Usage docs, traffic pattern visualization, environment variables, results interpretation guide
- package.json — Added test:load and test:load:quick scripts
- .gitignore — Added tests/load/results/ to ignore generated reports

**Decisions:**
- Used pure Node.js (node:http, node:https) instead of autocannon or external packages to keep zero external dependencies
- Traffic weights reflect realistic Show HN visitor behavior: majority hit landing page, small fraction explores API
- Rate-limited endpoints (demo/seed at 3/min, auth at 5/min) are included intentionally — 429s validate that rate limiting works under load
- Auto-obtains JWT auth via POST /api/v1/demo/seed so authenticated endpoints can be tested without manual setup
- Quick mode (--quick) runs in ~60 seconds for CI/pre-deploy smoke testing
- Reports saved as JSON for CI integration and trend analysis

**Status:** completed

## 21:00 — Comprehensive interactive API documentation page

**Task:** Rebuild the /docs API documentation page with full endpoint coverage, search, rate limits, and expandable sections

**Changes:**
- frontend/src/pages/ApiDocs.tsx — Complete rewrite of the API documentation page with:
  - 21 endpoint categories covering all 120+ REST API endpoints (Auth, Organizations, Contacts, Companies, Deals, Activities, Signals, Workflows, Playbooks, Scoring, Email Sequences, Connectors, Webhooks, Webhook Subscriptions, Analytics, Identity Resolution, Enrichment, Bulk Operations, Dashboards, Team Members, API Keys, Search, AI Engine)
  - Search/filter functionality with keyboard shortcut (/) to find endpoints by method, path, or description
  - Expandable/collapsible sections for each endpoint group with endpoint count badges
  - Expandable endpoint rows showing request body and response JSON examples with syntax highlighting
  - Rate limit reference table (5 tiers: auth 5/min, api 100/min, webhook 200/min, demo 3/min, signal 500/min)
  - Authentication section covering JWT, API Keys, and SSO (SAML/OIDC)
  - Quick Start guide with SDK installation, TypeScript, and curl examples
  - PLG pipeline stages, workflow trigger events, and webhook event types reference
  - Error handling reference with HTTP status codes
  - Sticky sidebar navigation with active section tracking via IntersectionObserver
  - Mobile-responsive with collapsible sidebar and mobile search
  - Dark theme matching existing design system

**Decisions:**
- Kept all data inline rather than fetching from OpenAPI spec to ensure the page loads instantly without backend dependency (important for pre-login evaluation)
- Used dangerouslySetInnerHTML for syntax highlighting in code blocks to avoid adding a syntax highlighting library dependency
- First 3 endpoint categories default to expanded; rest are collapsed to keep initial view clean
- Search filters across category labels, descriptions, endpoint paths, methods, and descriptions

**Status:** completed

## 23:30 — Pre-launch QA sweep: fix GraphQL endpoint shadowed by 404 catch-all

**Task:** Run full test suite, build checks, TypeScript checks, and audit for launch-day bugs
**Changes:**
- backend/src/app.ts — Fixed critical bug: the /api 404 catch-all middleware was intercepting /api/v1/graphql requests before the GraphQL handler (mounted later in server.ts) could process them. Added a path check to skip /v1/graphql so the request falls through to the Apollo Server handler.

**Audit results (no fix needed):**
- Frontend build: clean (251KB initial bundle)
- Backend tsc --noEmit: clean
- Frontend tsc --noEmit: clean
- All 54 route files are imported and mounted in app.ts (no orphans, no missing)
- Dockerfile multi-stage build paths verified correct (dist -> /app/dist, public -> /app/public)
- No hardcoded localhost URLs in frontend (all use import.meta.env.VITE_API_URL with empty string fallback)
- No TODO/FIXME/HACK markers in either backend or frontend source
- No unsafe raw queries ($queryRawUnsafe, $executeRawUnsafe)
- No password leaks in JSON responses
- .env is gitignored, secrets are not committed
- CORS, rate limiting, Stripe webhook raw body parsing all correctly configured

**Pre-existing test issues (not production bugs):**
- 4 integration test suites fail when Redis is unavailable (expected in CI without Redis)
- Auth integration tests hit rate limiter during rapid test execution (429 instead of expected status codes)
- webhook-subscriptions.test.ts has an outdated assertion expecting _subscriptionId/_targetUrl in payload (implementation correctly uses top-level job data fields)

**Status:** completed

## 23:45 — Enhanced health check and webhook delivery retry

**Task:** Production hardening: enhanced health check with dependency probes, webhook delivery retry with exponential backoff

**Changes:**
- backend/src/routes/health.ts — New health check router: GET /health (DB + Redis + memory, 3s timeout per check, healthy/degraded/unhealthy status), GET /health/ready (readiness probe, 200 only when all deps up)
- backend/src/app.ts — Replaced inline health handler with health routes module
- backend/prisma/schema.prisma — Added WebhookSubscriptionStatus enum (HEALTHY/FAILING), status field on WebhookSubscription, new WebhookSubscriptionDelivery model
- backend/prisma/migrations/20260216040000_add_webhook_delivery_tracking/ — Migration for delivery tracking
- backend/src/jobs/queue.ts — Updated webhook delivery queue: 30s base backoff, increased retention
- backend/src/jobs/workers.ts — Rewrote webhook worker: per-subscription delivery with retry, delivery recording, auto-FAILING/HEALTHY status management
- backend/src/services/webhook-subscriptions.ts — Added getSubscriptionDeliveries, getSubscriptionWithDeliveryStats, markSubscriptionFailing, markSubscriptionHealthy, recordSubscriptionDelivery
- backend/src/routes/webhook-subscriptions.ts — Added GET /:id/status (delivery stats + failure rate), GET /:id/deliveries (recent attempts)

**Decisions:**
- Used BullMQ's native exponential backoff (5 attempts, 30s base: 30/60/120/240/480s) instead of custom retry logic
- Health check runs DB and Redis probes in parallel with 3s timeout each
- Delivery records kept in DB for audit trail; BullMQ job logs for operational debugging

**Status:** completed

## 24:00 — Cycle 9: Error handling, connector health, test fixes

**Task:** Production polish: error boundary + 404 page, connector health dashboard, webhook test fix

**Changes:**
- frontend/src/components/ErrorBoundary.tsx — Upgraded to dark theme with DevSignal branding, Try Again + Go to Dashboard buttons, dev-mode collapsible stack trace
- frontend/src/pages/NotFound.tsx — Polished 404 page with gradient heading, pulsing background orbs, navigation links (Dashboard, API Docs, Home)
- frontend/src/components/ConnectorHealthCard.tsx — New dashboard widget showing all 16 connector statuses (Active/Syncing/Error/Paused/Not connected), fetches from /api/v1/sources + integration endpoints in parallel, error states highlighted, smart sorting
- frontend/src/pages/Dashboard.tsx — Added ConnectorHealthCard between stat cards and activity feed
- backend/src/services/__tests__/webhook-subscriptions.test.ts — Fixed outdated assertion: expect top-level subscriptionId/targetUrl/secret instead of nested _subscriptionId/_targetUrl in payload
- e2e/connectors-and-charts.spec.ts — 8 new E2E tests for Intercom/Zendesk settings UI and score trend visualizations

**Status:** completed

## 24:30 — Redesign keyboard shortcuts modal with dark theme

**Task:** Rebuild the keyboard shortcuts help modal with dark theme, complete shortcut catalog, accessibility improvements

**Changes:**
- frontend/src/components/KeyboardShortcuts.tsx — Full rewrite: dark theme (gray-900 background, gray-700 borders) matching app sidebar aesthetic, grouped shortcuts by category (Navigation with 10 "g then X" combos, Search with Cmd/Ctrl+K and Escape, General with "?" toggle), platform-aware modifier key detection (shows Cmd on macOS, Ctrl on others), styled kbd elements with inset shadow for physical key appearance, backdrop blur overlay, focus trap with previous-element restore on close, hover highlights on shortcut rows, scrollable on mobile with max-height constraint, proper ARIA dialog attributes, footer hint showing toggle shortcut

**Decisions:**
- Kept the modal mounted via Layout.tsx (no changes to App.tsx needed since the hook and toggle were already wired up in Layout)
- Used capture-phase Escape listener to prevent the shortcut hook from re-toggling the modal when Escape is pressed
- Platform detection uses navigator.platform with navigator.userAgent fallback for Mac detection

**Status:** completed

## 25:00 — Contact merge/deduplication UI and API

**Task:** Build duplicate contact detection and merge functionality (backend API + frontend UI)

**Changes:**
- backend/src/controllers/contacts.ts — Added getDuplicates controller (calls findDuplicates from identity-resolution service) and mergeContact controller (validates duplicateIds array, calls mergeContacts, logs audit trail)
- backend/src/routes/contacts.ts — Added GET /duplicates route (placed before /:id to avoid param conflicts) with OpenAPI docs, added POST /:id/merge route with OpenAPI docs and request body schema
- frontend/src/pages/ContactDuplicates.tsx — New page: fetches duplicate groups from API, shows side-by-side contact cards with detail fetching per card (email, company, phone, GitHub, title, creation date), confidence badges (Very High/High/Medium/Low with color coding), matched identity type pills, radio-style primary contact selection, merge button with loading spinner, dismiss button for false positives, re-scan action, empty state when no duplicates, back navigation to contacts list
- frontend/src/pages/Contacts.tsx — Added "Find Duplicates" link button in header toolbar (between Export CSV and Import CSV)
- frontend/src/App.tsx — Added lazy-loaded ContactDuplicates route at /contacts/duplicates (placed before /contacts/:id)

**Decisions:**
- Leveraged existing findDuplicates and mergeContacts functions from identity-resolution.ts rather than reimplementing detection logic
- Duplicate detection uses two strategies: same email address (exact match) and shared identity records (GitHub, npm, etc.)
- Frontend fetches individual contact details per card for richer side-by-side comparison
- Dismiss is client-side only (session memory) — dismissed groups reappear on re-scan, keeping it simple for v1
- No database migration needed — all functionality uses existing schema

**Status:** completed

## 25:30 — Cycle 11: Activity timeline, CSV export, onboarding checklist

**Task:** High-value UX features: contact activity timeline, filtered CSV export, persistent onboarding checklist

**Changes:**
- frontend/src/components/ActivityTimeline.tsx — New rich timeline: merged signals + activities chronological, source-specific SVG icons (GitHub, npm, Website, Segment), activity type icons, day grouping, filter tabs (All/Signals/Activities), load-more pagination, relative timestamps, intelligent signal descriptions
- frontend/src/pages/ContactDetail.tsx — Replaced inline timeline with ActivityTimeline component
- backend/src/controllers/contacts.ts — Added exportContacts handler (GET /contacts/export with search/companyId/sort params, streams CSV)
- backend/src/controllers/companies.ts — Added exportCompanies handler (GET /companies/export with search/industry/sort params, streams CSV)
- backend/src/routes/contacts.ts — Registered GET /export route before /:id
- backend/src/routes/companies.ts — Registered GET /export route before /:id
- frontend/src/pages/Contacts.tsx — Switched export to GET with current filters, dedicated exporting state
- frontend/src/pages/Companies.tsx — Added Export CSV button in header + bulk toolbar
- frontend/src/components/OnboardingChecklist.tsx — New persistent checklist: 6 auto-detecting steps (signal source, contacts, scoring, workflows, team, CRM), progress bar with percentage, dismissible via localStorage, collapsible to dot summary, auto-hides when complete
- frontend/src/pages/Dashboard.tsx — Replaced GettingStarted with OnboardingChecklist

**Status:** completed

## 26:00 — Cycle 12: Usage enforcement, weekly digest, SEO/legal

**Task:** Revenue infrastructure: billing enforcement, retention emails, SEO essentials and legal compliance

**Changes:**
- backend/src/middleware/usage-limits.ts — Tier limit enforcement: checks contacts/signals/users against plan, returns 402 with limit details
- backend/src/services/usage.ts — Usage summary service (current counts vs tier limits)
- backend/src/routes/usage.ts — GET /api/v1/usage endpoint
- backend/src/services/billing.ts — Updated with tier limit constants for all 4 plans
- frontend/src/components/UsageBanner.tsx — Global banner: yellow at 80%+, red at 100%, upgrade CTA
- frontend/src/components/UpgradeModal.tsx — Modal on 402 responses with tier comparison
- frontend/src/lib/api.ts — 402 interceptor triggers upgrade flow
- backend/src/services/weekly-digest.ts — Generates per-org digest: signal counts by source, top 5 active companies, new contacts, PQA tier changes
- backend/src/services/email-templates.ts — Responsive HTML email template with DevSignal branding, inline CSS, unsubscribe link
- backend/src/jobs/queue.ts — WEEKLY_DIGEST queue
- backend/src/jobs/scheduler.ts — Monday 9 AM UTC cron + enqueueWeeklyDigestForAllOrgs
- backend/src/routes/seo.ts — GET /sitemap.xml (9 pages, 24h cache) + GET /robots.txt
- frontend/src/pages/Terms.tsx — 12-section Terms of Service with sticky TOC sidebar
- frontend/src/pages/Privacy.tsx — GDPR-aware Privacy Policy, 11 sections, lists all third-party services
- frontend/src/pages/Landing.tsx — Added Terms/Privacy footer links

**Decisions:**
- Usage enforcement returns 402 (not 403) to distinguish from auth errors
- Weekly digest cron fires Monday 9 AM UTC to catch start-of-week
- Terms/Privacy use "DevSignal, Inc." and "legal@devsignal.dev"
- sitemap.xml mounted before API middleware for direct crawler access

**Status:** completed

## 26:30 — Notification preferences (backend + frontend)

**Task:** Build notification preferences so users can control what alerts they receive, reducing churn from over-notification.

**Changes:**
- backend/prisma/schema.prisma — Added NotificationPreference model (1:1 with User), EmailDigestFrequency enum (DAILY/WEEKLY/NEVER), SignalAlertLevel enum (ALL/HOT_ONLY/NONE); five preference fields: emailDigest, signalAlerts, workflowNotifications, teamMentions, usageLimitWarnings
- backend/prisma/migrations/20260216060000_add_notification_preferences/migration.sql — Migration: creates enums, notification_preferences table with unique userId constraint and foreign key
- backend/src/services/notifications.ts — Added getNotificationPreferences (returns persisted prefs or defaults), upsertNotificationPreferences (partial update with upsert), NotificationPreferenceData/Response types, DEFAULT_PREFERENCES constant
- backend/src/routes/notifications.ts — Added GET /notifications/preferences and PUT /notifications/preferences with full OpenAPI docs and input validation for enum/boolean fields
- frontend/src/pages/Settings.tsx — Added 'notifications' to TabId and TABS array, added NotificationsTab component (loads prefs on mount, auto-saves on change with toast feedback), added ToggleSwitch component (accessible role=switch toggle), added NotificationPreferences/EmailDigestFrequency/SignalAlertLevel types; five preference controls: email digest frequency selector, signal alert level selector, workflow/team mentions/usage limit toggle switches

**Decisions:**
- Used upsert pattern so preferences are created on first save rather than on user creation (no migration backfill needed for existing users)
- GET endpoint returns defaults when no record exists, so the frontend always gets a valid response
- Auto-save on each individual field change (no submit button) for better UX
- Added NotificationsTab as the 4th tab (after Signal Sources, before Slack) for discoverability
- ToggleSwitch uses role="switch" with aria-checked for accessibility

**Status:** completed
