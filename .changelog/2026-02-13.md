## 18:30 — P5: Stripe billing, usage limits, and billing UI

**Task:** Complete and commit the abandoned billing/usage-limits sprint — fix test breakage, commit the full feature
**Changes:**
- backend/src/services/billing.ts — Stripe billing service: checkout sessions, customer portal, webhook handler (checkout.completed, subscription.updated, subscription.deleted, invoice.payment_failed). Fixed eager Stripe client init to lazy-init so tests don't crash on import.
- backend/src/services/usage.ts — Usage service: plan limit definitions (Free/Pro/Scale), real-time usage counts, limit checking
- backend/src/middleware/usage-limits.ts — Plan enforcement middleware: enforceContactLimit, enforceSignalLimit, enforceUserLimit (returns 402 when over plan)
- backend/src/routes/billing.ts — Billing routes: POST /checkout, POST /portal, GET /subscription, plus raw-body webhook endpoint
- backend/src/routes/usage.ts — Usage route: GET /usage returns plan + usage + limits with OpenAPI docs
- backend/src/routes/contacts.ts — Added enforceContactLimit middleware to POST /contacts
- backend/src/routes/signals.ts — Added enforceSignalLimit middleware to POST /signals and POST /signals/batch
- backend/src/config/index.ts — Added stripe config block (secretKey, webhookSecret, pricePro, priceScale) with dev fallbacks
- backend/src/app.ts — Wired usage + billing routes, mounted webhook before express.json() for raw body access
- backend/package.json — Added stripe dependency
- frontend/src/pages/Billing.tsx — Full billing page: current plan banner, usage progress bars, plan comparison cards, Stripe checkout + portal integration
- frontend/src/App.tsx — Added /billing route
- frontend/src/components/Layout.tsx — Added Billing nav link with credit card icon in sidebar

**Decisions:**
- Lazy-initialized Stripe client via getStripe() instead of top-level `new Stripe()` — the eager init caused 5 integration test suites to crash because they import app.ts which imports billing.ts
- Replaced PRICE_TO_PLAN lookup table with inline function to avoid top-level config access
- Billing data stored in Organization.settings JSON field (no schema migration needed)
- Webhook endpoint mounted before express.json() middleware for raw body signature verification
- Usage limits fail open (if limit check errors, request proceeds) to avoid blocking production traffic

**Open questions:**
- Stripe price IDs are placeholders — need real Stripe product/price setup before going live
- No Prisma migration needed since billing state lives in settings JSON, but consider a dedicated table if billing logic grows

**Status:** completed

## 19:15 — P6: Analytics, contact timeline, workflow automation engine

**Task:** Build the intelligence layer — analytics API with charts, contact signal timeline, and workflow automation engine
**Changes:**
- backend/prisma/schema.prisma — Added Workflow + WorkflowRun models with WorkflowRunStatus enum
- backend/src/services/analytics.ts — Analytics service: overview stats, signal trends (raw SQL), PQA distribution, pipeline funnel, top signal types
- backend/src/routes/analytics.ts — GET /analytics, /signal-trends, /pqa-distribution, /pipeline, /top-signals
- backend/src/services/workflows.ts — Workflow automation engine: CRUD, condition evaluation (8 operators), action execution (create_deal, update_deal_stage, send_webhook, send_slack, add_tag, log), event processing with run tracking
- backend/src/routes/workflows.ts — Full workflow CRUD: POST/GET/PUT/DELETE /workflows, GET /:id/runs, POST /process-event
- backend/src/app.ts — Wired analytics + workflow routes
- frontend/src/pages/Dashboard.tsx — Enhanced with analytics charts: signal volume bar chart (30d), PQA score distribution bars, top signal types chart
- frontend/src/pages/ContactDetail.tsx — Added signal timeline: merges signals + activities + deals in chronological order with left-border timeline UI and relative timestamps
- frontend/src/pages/Workflows.tsx — Full workflow management page: list with run history expansion, create/edit modal with trigger events, filter builder, multi-action builder with type-specific param hints, enabled toggle
- frontend/src/App.tsx — Added /workflows route
- frontend/src/components/Layout.tsx — Added Workflows nav link with icon

**Decisions:**
- Used pure CSS/Tailwind bar charts instead of a chart library — zero dependencies, good enough for MVP, can swap in recharts later if needed
- Workflow actions for send_webhook, send_slack, add_tag are placeholder implementations (log only) — will integrate with actual Slack/webhook services in P7
- Signal trends use raw SQL (CURRENT_DATE - days::integer) for performance on large signal tables
- Workflow conditions use AND logic (all must pass). OR logic can be added later by nesting condition groups
- No Prisma migration run (schema only) — migration needed before deployment

**Open questions:**
- Should workflow processing be async via BullMQ? Currently synchronous in processEvent(), which is fine for low-volume but won't scale
- Consider adding a "test workflow" button that simulates an event without recording a run

**Status:** completed

## 20:00 — P7: Wire workflow automation into live trigger points

**Task:** Connect the workflow engine to real events so workflows actually fire — not just dead code
**Changes:**
- backend/src/controllers/signals.ts — Added processEvent('signal_received') fire-and-forget call in ingestSignal handler
- backend/src/controllers/contacts.ts — Added processEvent('contact_created') fire-and-forget call in createContact handler
- backend/prisma/migrations/20260213000000_add_workflow_automation/migration.sql — SQL migration for workflows + workflow_runs tables with indexes and foreign keys

**Decisions:**
- Fire-and-forget pattern with `.catch()` to avoid blocking API responses
- Migration created manually (not via `prisma migrate dev`) to keep it deterministic and CI-friendly

**Status:** completed

## 20:45 — P8: Production-ready intelligence — real workflow actions, all triggers, Settings hub

**Task:** Make workflows fully functional (real HTTP, Slack, tagging), wire all 4 trigger types, and build a comprehensive Settings page
**Changes:**
- backend/src/controllers/deals.ts — Wire deal_stage_changed workflow trigger: fetch old stage before update, fire processEvent on stage change
- backend/src/services/account-scores.ts — Wire score_changed workflow trigger: fire processEvent when PQA tier changes
- backend/src/services/workflows.ts — Replace placeholder workflow actions with real implementations:
  - send_webhook: actual HTTP POST with 10s timeout via fetch()
  - send_slack: sends to org's configured Slack webhook with Block Kit formatting
  - add_tag: creates/finds tag via Prisma upsert, attaches to contact/company/deal from context
- backend/src/services/slack-notifications.ts — Exported getSlackWebhookUrl for reuse by workflow engine
- backend/src/__tests__/controllers/deals.test.ts — Updated tests: mock getDealById call before updateDeal, mock processEvent module
- frontend/src/pages/Settings.tsx — Complete rewrite (268 → 1,301 lines): 4-tab Settings hub:
  - API Keys: list, create (with copy-once key banner), revoke, delete
  - Webhooks: list endpoints, create with event checkboxes, toggle active, delete
  - Signal Sources: list with status indicators, empty state with SDK setup instructions
  - Slack: preserved existing integration UI (save, test, disconnect)
  - Shared: Modal, Badge, StatusDot components, lazy tab loading

**Decisions:**
- send_webhook uses native fetch() with AbortSignal.timeout(10s) to prevent hanging
- send_slack reuses existing Slack webhook URL from org settings (no separate config)
- add_tag uses upsert pattern to avoid duplicates, attaches to whichever entity is in context
- Settings tabs are lazy-mounted (only render on first visit) to avoid unnecessary API calls
- All 4 workflow triggers now wired: signal_received, contact_created, deal_stage_changed, score_changed

**Open questions:**
- Webhook retry logic (currently fire-once) — consider BullMQ for reliable delivery
- Settings page could benefit from URL-based tab routing (/settings/api-keys) in a future pass

**Status:** completed

## 21:30 — P9: Deal Detail page and entity navigation

**Task:** Build Deal Detail page with inline editing, stage management, and cross-entity navigation
**Changes:**
- frontend/src/pages/DealDetail.tsx — New 736-line Deal Detail page with:
  - Inline-editable title, amount, description, probability, expected close date
  - Stage dropdown with optimistic update
  - Activities list with type icons, status/priority badges
  - Tags display with color support
  - Right column: linked contact (→ /contacts/:id), company (→ /companies/:id), owner, metadata
  - Delete with confirmation → redirect to /deals
- frontend/src/App.tsx — Added /deals/:id route with DealDetail import
- frontend/src/pages/Deals.tsx — Made deal titles clickable in both pipeline and list views (Link to /deals/:id)

**Decisions:**
- Inline editing uses click-to-edit pattern with blur/enter save and escape cancel
- Stage changes are optimistic (UI updates immediately, PUT fires async, reverts on failure)
- Design matches existing ContactDetail and CompanyDetail pages for consistency

**Status:** completed

## 22:00 — P10: npm signal connector

**Task:** Build npm registry connector to automatically ingest package download stats and metadata as signals
**Changes:**
- backend/src/services/npm-connector.ts — npm connector service: syncNpmSource fetches weekly download stats + registry metadata per package, creates idempotent signals, matches maintainer email domains to company records; syncAllNpmSources for cron; testNpmConnection for connectivity checks
- backend/src/routes/connectors.ts — Connector routes: POST /connectors/npm/:sourceId/sync (trigger sync), POST /connectors/npm/test (test API connectivity with zod validation)
- backend/src/app.ts — Wired connector routes at /api/v1/connectors

**Decisions:**
- Used native fetch() with AbortSignal.timeout(10s) for npm API calls — no extra HTTP dependencies
- Idempotency key pattern: npm_{package}_{end_date} to prevent duplicate signals on re-sync
- Generic email provider filtering (gmail, yahoo, etc.) to avoid false company domain matches
- Registry metadata fetch is best-effort — download stats still recorded if registry call fails
- Handles Prisma P2002 (unique constraint) gracefully for duplicate idempotency keys

**Open questions:**
- Cron scheduling for syncAllNpmSources not yet configured — needs BullMQ job or external cron
- PyPI connector planned as next connector type

**Status:** completed

## 22:30 — P11: Playwright E2E test suite

**Task:** Set up Playwright and write comprehensive E2E tests for all critical user flows
**Changes:**
- playwright.config.ts — Config: Chromium-only, serial execution, webServer auto-start for backend (:4000) + frontend (:5173), HTML reporter, screenshot on failure, trace on retry
- e2e/helpers/api.ts — Test helper: createTestUser() registers user + creates org via API, authHeaders() returns Bearer + X-Organization-Id headers
- e2e/helpers/auth.ts — Test helper: loginViaUI() fills login form, injectAuth() sets localStorage tokens for fast auth bypass
- e2e/auth.spec.ts — 8 tests: register → onboarding redirect, login with valid/bad credentials, error display, logout + token clearing, protected route guard
- e2e/contacts.spec.ts — 8 tests: create via modal, view detail, direct URL, search/filter with debounce, no-results state, clear search, delete with confirm/cancel
- e2e/deals.spec.ts — 4 tests: pipeline + list views, create deal, deal detail navigation, stage dropdown with optimistic update + persistence verify
- e2e/signals.spec.ts — 2 tests: signal feed display with seeded data, API-ingested signal appears in feed with metadata expansion
- e2e/navigation.spec.ts — 13 tests: 10 sidebar links navigate correctly, all links present, 404 page, auth redirect when unauthenticated
- e2e/search.spec.ts — 3 tests: global search modal opens, contact search returns results, no-results empty state
- package.json — Added e2e, e2e:ui, e2e:headed scripts; @playwright/test devDependency
- .gitignore — Added Playwright artifacts (test-results/, playwright-report/, blob-report/)
- .github/workflows/ci.yml — Added E2E job: Postgres + Redis services, Prisma setup, Playwright install, artifact upload; deploy now depends on e2e

**Decisions:**
- Serial execution (workers: 1) to avoid DB state conflicts between parallel tests
- Each test creates its own user+org via API to be fully independent
- injectAuth() sets localStorage directly for speed instead of going through login form each time
- webServer config auto-starts backend + frontend in dev mode, with reuseExistingServer for local development
- 38 total tests covering auth, contacts CRUD, deals pipeline, signals, navigation, search

**Status:** completed

## 23:00 — P12: PyPI connector + bulk operations + CSV export

**Task:** Add PyPI signal connector (sister to npm), bulk delete/tag/export operations for contacts/companies/deals
**Changes:**
- backend/prisma/schema.prisma — Added PYPI to SignalSourceType enum
- backend/prisma/migrations/20260213010000_add_pypi_source_type/migration.sql — Enum migration
- backend/src/services/pypi-connector.ts — PyPI connector: syncPypiSource (pypistats.org downloads + pypi.org metadata), company domain matching from author/maintainer emails, syncAllPypiSources for cron, testPypiConnection
- backend/src/routes/connectors.ts — Added PyPI routes: POST /pypi/:sourceId/sync, POST /pypi/test; refactored shared validation schema
- backend/src/routes/bulk.ts — Bulk operations: POST /contacts/delete (max 500), /contacts/tag (upsert tag + skipDuplicates), /contacts/export (CSV with field escaping, includes company+PQA), /companies/delete, /deals/delete
- backend/src/app.ts — Wired bulk routes at /api/v1/bulk

**Decisions:**
- PyPI downloads use pypistats.org (last_week) since PyPI itself doesn't expose download counts
- PyPI email parsing handles comma-separated multi-email fields (common in setup.py)
- CSV export has 10,000 row safety cap; supports both id-based and search-based export
- CSV field escaping handles commas, quotes, and newlines per RFC 4180
- Bulk tag uses Prisma skipDuplicates to avoid errors on re-tagging
- All bulk operations scoped to organizationId for multi-tenancy

**Status:** completed

## 23:30 — P13: Frontend bulk operations UI

**Task:** Add bulk selection, delete, tag, and CSV export UI to Contacts, Companies, and Deals pages
**Changes:**
- frontend/src/pages/Contacts.tsx — Row selection checkboxes with select-all, bulk action toolbar (Delete with confirmation modal, Add Tag with name input modal, Export Selected as CSV download), Export CSV button in header for all/filtered contacts
- frontend/src/pages/Companies.tsx — Select mode toggle button, checkbox overlay on card grid, selected cards highlighted with indigo ring, bulk delete with confirmation modal, select-all on page, clear selection
- frontend/src/pages/Deals.tsx — Bulk selection in list view only (not pipeline), checkbox column with select-all, bulk action bar with delete, confirmation modal, clear selection on view mode switch

**Decisions:**
- Contacts table: checkboxes always visible (most common bulk ops pattern for tables)
- Companies card grid: explicit "Select" mode toggle since checkboxes on cards would clutter the default view
- Deals: bulk ops only in list view — pipeline kanban view is for drag-and-drop stage changes, not bulk selection
- CSV export uses blob download with `responseType: 'blob'` to handle binary response
- Selection clears on page change, search change, and view mode switch to avoid stale selections
- Export supports both selected-ids mode and search-filter mode (exports all matching contacts if none selected)

**Status:** completed

## 00:00 — P14: Notification center + keyboard shortcuts

**Task:** Build in-app notification system (backend + frontend) and global keyboard shortcuts for power-user navigation
**Changes:**
- backend/prisma/schema.prisma — Added Notification model with userId, organizationId, type, title, body, entityType, entityId, read flag
- backend/prisma/migrations/20260213020000_add_notifications/migration.sql — CREATE TABLE + indexes migration
- backend/src/services/notifications.ts — Notification service: createNotification (with WebSocket broadcast), getNotifications (paginated with cursor), markAsRead, markAllAsRead, getUnreadCount, notifyOrgUsers
- backend/src/routes/notifications.ts — GET /notifications, GET /notifications/unread-count, POST /:id/read, POST /read-all
- backend/src/app.ts — Wired notification routes at /api/v1/notifications
- frontend/src/components/NotificationBell.tsx — Bell icon with red unread badge, dropdown panel with notification list, type-specific icons (deal/workflow/contact/score), relative time, mark-as-read on click, mark-all-as-read, WebSocket real-time updates, click-outside-to-close
- frontend/src/lib/useKeyboardShortcuts.ts — "g then X" two-key navigation (g d=Dashboard, g c=Contacts, g o=Companies, etc.), "?" for help
- frontend/src/components/KeyboardShortcuts.tsx — Help modal with all shortcuts, kbd-styled keys, Escape to close
- frontend/src/components/Layout.tsx — Added NotificationBell in sidebar header + mobile header, keyboard shortcuts hint button, shortcuts modal

**Decisions:**
- Notification bell placed in sidebar header (desktop) and mobile top bar (mobile) for consistent access
- "g then X" pattern inspired by GitHub/Gmail keyboard shortcuts — 1 second timeout for second key
- Shortcuts only active when not typing in inputs/textareas/selects to avoid conflicts
- Notification click navigates to entity detail page based on entityType/entityId
- notifyOrgUsers() helper for broadcasting to all org members (used by workflow actions, deal updates)
- Cursor-based pagination for notification list (more efficient for chronological feeds)

**Open questions:**
- Wire notifications into workflow engine (processEvent) and deal stage changes — separate PR
- Consider notification preferences (email, in-app toggle per type)

**Status:** completed

## 00:30 — P15: Wire notifications into live trigger points

**Task:** Connect notifyOrgUsers into all real event handlers so the notification bell shows actual activity
**Changes:**
- backend/src/controllers/contacts.ts — Added notifyOrgUsers fire-and-forget call in createContact (type: contact_created, with name + email)
- backend/src/controllers/deals.ts — Added notifyOrgUsers in createDeal (type: deal_created) and updateDeal stage-change block (type: deal_stage_changed, with amount display)
- backend/src/services/workflows.ts — Added notifyOrgUsers when a workflow run fails (type: workflow_failed, with error message and workflow link)

**Decisions:**
- Signals intentionally excluded from in-app notifications — too high volume, already covered by Slack alerts
- Workflow success not notified (would be noisy) — only failures surface to users
- Used `req.user?.id` (not `req.userId`) for excludeUserId to match Express type declaration
- All notification calls are fire-and-forget with `.catch()` to avoid blocking API responses

**Status:** completed
