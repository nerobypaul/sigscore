## 18:30 — P5: Stripe billing, usage limits, and billing UI

**Task:** Complete and commit the abandoned billing/usage-limits sprint — fix test breakage, commit the full feature
**Changes:**
- backend/src/services/billing.ts — Stripe billing service: checkout sessions, customer portal, webhook handler (checkout.completed, subscription.updated, subscription.deleted, invoice.payment_failed). Fixed eager Stripe client init to lazy-init so tests don't crash on import.
- backend/src/services/usage.ts — Usage service: plan limit definitions (Free/Pro/Scale), real-time usage counts, limit checking
- backend/src/middleware/usage-limits.ts — Plan enforcement middleware: enforceContactLimit, enforceSignalLimit, enforceUserLimit (returns 402 when over plan)
- backend/src/routes/billing.ts — Billing routes: POST /checkout, POST /portal, GET /subscription, plus raw-body webhook endpoint
- backend/src/routes/usage.ts — Usage route: GET /usage returns plan + usage + limits with OpenAPI docs
- backend/src/routes/contacts.ts — Added enforceContactLimit middleware to POST /contacts
- backend/src/routes/signals.ts — Added enforceSignalLimit middleware to POST /signals and POST /signals/batch
- backend/src/config/index.ts — Added stripe config block (secretKey, webhookSecret, pricePro, priceScale) with dev fallbacks
- backend/src/app.ts — Wired usage + billing routes, mounted webhook before express.json() for raw body access
- backend/package.json — Added stripe dependency
- frontend/src/pages/Billing.tsx — Full billing page: current plan banner, usage progress bars, plan comparison cards, Stripe checkout + portal integration
- frontend/src/App.tsx — Added /billing route
- frontend/src/components/Layout.tsx — Added Billing nav link with credit card icon in sidebar

**Decisions:**
- Lazy-initialized Stripe client via getStripe() instead of top-level `new Stripe()` — the eager init caused 5 integration test suites to crash because they import app.ts which imports billing.ts
- Replaced PRICE_TO_PLAN lookup table with inline function to avoid top-level config access
- Billing data stored in Organization.settings JSON field (no schema migration needed)
- Webhook endpoint mounted before express.json() middleware for raw body signature verification
- Usage limits fail open (if limit check errors, request proceeds) to avoid blocking production traffic

**Open questions:**
- Stripe price IDs are placeholders — need real Stripe product/price setup before going live
- No Prisma migration needed since billing state lives in settings JSON, but consider a dedicated table if billing logic grows

**Status:** completed

## 19:15 — P6: Analytics, contact timeline, workflow automation engine

**Task:** Build the intelligence layer — analytics API with charts, contact signal timeline, and workflow automation engine
**Changes:**
- backend/prisma/schema.prisma — Added Workflow + WorkflowRun models with WorkflowRunStatus enum
- backend/src/services/analytics.ts — Analytics service: overview stats, signal trends (raw SQL), PQA distribution, pipeline funnel, top signal types
- backend/src/routes/analytics.ts — GET /analytics, /signal-trends, /pqa-distribution, /pipeline, /top-signals
- backend/src/services/workflows.ts — Workflow automation engine: CRUD, condition evaluation (8 operators), action execution (create_deal, update_deal_stage, send_webhook, send_slack, add_tag, log), event processing with run tracking
- backend/src/routes/workflows.ts — Full workflow CRUD: POST/GET/PUT/DELETE /workflows, GET /:id/runs, POST /process-event
- backend/src/app.ts — Wired analytics + workflow routes
- frontend/src/pages/Dashboard.tsx — Enhanced with analytics charts: signal volume bar chart (30d), PQA score distribution bars, top signal types chart
- frontend/src/pages/ContactDetail.tsx — Added signal timeline: merges signals + activities + deals in chronological order with left-border timeline UI and relative timestamps
- frontend/src/pages/Workflows.tsx — Full workflow management page: list with run history expansion, create/edit modal with trigger events, filter builder, multi-action builder with type-specific param hints, enabled toggle
- frontend/src/App.tsx — Added /workflows route
- frontend/src/components/Layout.tsx — Added Workflows nav link with icon

**Decisions:**
- Used pure CSS/Tailwind bar charts instead of a chart library — zero dependencies, good enough for MVP, can swap in recharts later if needed
- Workflow actions for send_webhook, send_slack, add_tag are placeholder implementations (log only) — will integrate with actual Slack/webhook services in P7
- Signal trends use raw SQL (CURRENT_DATE - days::integer) for performance on large signal tables
- Workflow conditions use AND logic (all must pass). OR logic can be added later by nesting condition groups
- No Prisma migration run (schema only) — migration needed before deployment

**Open questions:**
- Should workflow processing be async via BullMQ? Currently synchronous in processEvent(), which is fine for low-volume but won't scale
- Consider adding a "test workflow" button that simulates an event without recording a run

**Status:** completed

## 20:00 — P7: Wire workflow automation into live trigger points

**Task:** Connect the workflow engine to real events so workflows actually fire — not just dead code
**Changes:**
- backend/src/controllers/signals.ts — Added processEvent('signal_received') fire-and-forget call in ingestSignal handler
- backend/src/controllers/contacts.ts — Added processEvent('contact_created') fire-and-forget call in createContact handler
- backend/prisma/migrations/20260213000000_add_workflow_automation/migration.sql — SQL migration for workflows + workflow_runs tables with indexes and foreign keys

**Decisions:**
- Fire-and-forget pattern with `.catch()` to avoid blocking API responses
- Migration created manually (not via `prisma migrate dev`) to keep it deterministic and CI-friendly

**Status:** completed

## 20:45 — P8: Production-ready intelligence — real workflow actions, all triggers, Settings hub

**Task:** Make workflows fully functional (real HTTP, Slack, tagging), wire all 4 trigger types, and build a comprehensive Settings page
**Changes:**
- backend/src/controllers/deals.ts — Wire deal_stage_changed workflow trigger: fetch old stage before update, fire processEvent on stage change
- backend/src/services/account-scores.ts — Wire score_changed workflow trigger: fire processEvent when PQA tier changes
- backend/src/services/workflows.ts — Replace placeholder workflow actions with real implementations:
  - send_webhook: actual HTTP POST with 10s timeout via fetch()
  - send_slack: sends to org's configured Slack webhook with Block Kit formatting
  - add_tag: creates/finds tag via Prisma upsert, attaches to contact/company/deal from context
- backend/src/services/slack-notifications.ts — Exported getSlackWebhookUrl for reuse by workflow engine
- backend/src/__tests__/controllers/deals.test.ts — Updated tests: mock getDealById call before updateDeal, mock processEvent module
- frontend/src/pages/Settings.tsx — Complete rewrite (268 → 1,301 lines): 4-tab Settings hub:
  - API Keys: list, create (with copy-once key banner), revoke, delete
  - Webhooks: list endpoints, create with event checkboxes, toggle active, delete
  - Signal Sources: list with status indicators, empty state with SDK setup instructions
  - Slack: preserved existing integration UI (save, test, disconnect)
  - Shared: Modal, Badge, StatusDot components, lazy tab loading

**Decisions:**
- send_webhook uses native fetch() with AbortSignal.timeout(10s) to prevent hanging
- send_slack reuses existing Slack webhook URL from org settings (no separate config)
- add_tag uses upsert pattern to avoid duplicates, attaches to whichever entity is in context
- Settings tabs are lazy-mounted (only render on first visit) to avoid unnecessary API calls
- All 4 workflow triggers now wired: signal_received, contact_created, deal_stage_changed, score_changed

**Open questions:**
- Webhook retry logic (currently fire-once) — consider BullMQ for reliable delivery
- Settings page could benefit from URL-based tab routing (/settings/api-keys) in a future pass

**Status:** completed
